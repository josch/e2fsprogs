# vim: filetype=sh

test_description="create fs image from GNU tarball"
if ! test -x "$DEBUGFS_EXE"; then
	echo "$test_name: $test_description: skipped (no debugfs)"
	return 0
fi
if [ "$(grep -c 'define HAVE_ARCHIVE_H' ../lib/config.h)" -eq 0 ]; then
	echo "$test_name: $test_description: skipped (no libarchive)"
	exit 0
fi

MKFS_TAR="$TMPFILE.tar"
MKFS_DIR="$TMPFILE.dir"
OUT="$test_name.log"
EXP="$test_dir/expect"

# we put everything in a subdir because we cannot rdump the root as that would
# require permissions to changing ownership of /lost+found
rm -rf "$MKFS_DIR"
mkdir -p "$MKFS_DIR/test"
touch "$MKFS_DIR/test/emptyfile"
dd if=/dev/zero bs=1024 count=32 2> /dev/null | tr '\0' 'a' > "$MKFS_DIR/test/bigfile"
dd if=/dev/zero of="$MKFS_DIR/test/zerofile" bs=1 count=1 seek=1024 2> /dev/null
ln -s /silly_bs_link "$MKFS_DIR/test/silly_bs_link"
mkdir "$MKFS_DIR/test/emptydir"
mkdir "$MKFS_DIR/test/dir"
echo "will be overwritten" > "$MKFS_DIR/test/dir/file"

# debugfs rdump does not preserve the timestamps when it extracts the
# files so we ignore them by using tar --clamp-mtime
# first write a partial tar
tar --sort=name -C "$MKFS_DIR" --mtime="$DEBUGFS_EXE" --clamp-mtime --format=gnu -cf "$MKFS_TAR.dupl" test
# now overwrite the contents of a file
echo "Test me" > "$MKFS_DIR/test/dir/file"
# and update the tar so that it contains two entries for the same file
# we need this to test the code path that first unlinks and then overwrites an
# existing file
tar -C "$MKFS_DIR" --mtime="$DEBUGFS_EXE" --clamp-mtime --format=gnu -rf "$MKFS_TAR.dupl" test/dir/file
# also add a duplicate directory entry because those must not be unlinked
echo test | tar -C "$MKFS_DIR" --mtime="$DEBUGFS_EXE" --clamp-mtime --format=gnu -rf "$MKFS_TAR.dupl" -T -
# also create a tarball of the directory with only one entry per file
tar --sort=name -C "$MKFS_DIR" --mtime="$DEBUGFS_EXE" --clamp-mtime --format=gnu -cf "$MKFS_TAR.uniq" test
rm -r "$MKFS_DIR"

cat > "$TMPFILE.cmd1" << ENDL
stat /test/emptyfile
stat /test/bigfile
stat /test/zerofile
stat /test/silly_bs_link
stat /test/emptydir
stat /test/dir
stat /test/dir/file
ENDL

cat > "$TMPFILE.cmd2" << ENDL
ex /test/emptyfile
ex /test/bigfile
ex /test/zerofile
ex /test/silly_bs_link
ex /test/emptydir
ex /test/dir
ex /test/dir/file
ENDL

# Create two file systems, one for each tar that was created above. The
# tarballs differ but should result in the same filesystem contents
#
for ext in uniq dupl; do
	mkdir "$MKFS_DIR"
	{
		$MKE2FS -q -F -o Linux -T ext4 -O metadata_csum,64bit -E lazy_itable_init=1 -b 1024 -d "$MKFS_TAR.$ext" "$TMPFILE.$ext" 16384 2>&1;
		echo Exit status is $?;
		$DUMPE2FS "$TMPFILE.$ext" 2>&1;
		echo Exit status is $?;
		$DEBUGFS -f "$TMPFILE.cmd1" "$TMPFILE.$ext" 2>&1 | grep -E "(stat|Size:|Type:|Links:|Blockcount:)"
		echo Exit status is $?;
		$DEBUGFS -f "$TMPFILE.cmd2" "$TMPFILE.$ext" 2>&1;
		echo Exit status is $?;
		$DEBUGFS -R "dump /test/dir/file $TMPFILE.testme" "$TMPFILE.$ext" 2>&1;
		echo Exit status is $?;
		# extract the files and directories from the image and tar them
		# again to make sure that a tarball from the image contents is
		# bit-by-bit identical to the tarball the image was created
		# from -- essentially this checks whether a roundtrip from tar
		# to ext4 to tar remains identical
		$DEBUGFS -R "rdump /test $MKFS_DIR" "$TMPFILE.$ext" 2>&1;
		echo Exit status is $?;
		# debugfs rdump does not preserve the timestamps when it extracts the
		# files so we ignore them by using tar --clamp-mtime
		tar --sort=name -C "$MKFS_DIR" --mtime="$DEBUGFS_EXE" --clamp-mtime --format=gnu -cvf "$TMPFILE.new.tar" test 2>&1;
		echo Exit status is $?;
		$FSCK -f -n "$TMPFILE.$ext" 2>&1;
		echo Exit status is $?;
		# independent from which tarball the ext4 image was created,
		# the tarball created from the files in it should be bit-by-bit
		# identical to the tarball without duplicate entries
		cmp "$MKFS_TAR.uniq" "$TMPFILE.new.tar" 2>&1;
		echo Exit status is $?;
	} | sed -f "$cmd_dir/filter.sed" -f "$test_dir/output.sed" -e "s;$TMPFILE.$ext;test.img;" | {
		# In the first pass, store the output and append to the log
		# file. In the second pass, compare the output to the output
		# to the one from the first.
		case $ext in
			uniq) tee "$TMPFILE.log" >> "$OUT";;
			dupl) cmp - "$TMPFILE.log" >> "$OUT" 2>&1 || echo "cmp failed" >> "$OUT";;
		esac
	}
	rm -r "$MKFS_DIR" "$TMPFILE.new.tar"
done

# Do the verification
cmp -s "$OUT" "$EXP"
status=$?

if [ "$status" = 0 ] ; then
	echo "$test_name: $test_description: ok"
	touch "$test_name.ok"
else
	echo "$test_name: $test_description: failed"
	diff $DIFF_OPTS "$EXP" "$OUT" > "$test_name.failed"
fi

rm -rf "$MKFS_TAR.dupl" "$MKFS_TAR.uniq" "$TMPFILE.cmd1" "$TMPFILE.cmd2" "$TMPFILE.log"
unset MKFS_TAR MKFS_DIR OUT EXP
